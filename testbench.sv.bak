`timescale 1ns/1ps

//----------------------------------------------------------
// Clase RCSG: generación de estímulos aleatorios controlados
//----------------------------------------------------------
class numeros_rcsg;
  rand logic signed [7:0] A;
  rand logic signed [7:0] B;

  // Constraints de paridad
  constraint c_PP { A[0] == 1'b0; B[0] == 1'b0; }
  constraint c_PI { A[0] == 1'b0; B[0] == 1'b1; }
  constraint c_IP { A[0] == 1'b1; B[0] == 1'b0; }
  constraint c_II { A[0] == 1'b1; B[0] == 1'b1; }
endclass


//----------------------------------------------------------
// Módulo modelo de referencia (multiplicador ideal)
//----------------------------------------------------------
module multipli_parallel (
  input  logic signed [7:0] A,
  input  logic signed [7:0] B,
  output logic signed [15:0] S
);
  assign S = A * B;
endmodule


//----------------------------------------------------------
// Program: entorno de verificación avanzado
//----------------------------------------------------------
program automatic tb_multipli_prog
(
  input  logic              clk,
  output logic              reset,
  output logic              start,
  output logic signed [7:0] A,
  output logic signed [7:0] B,
  input  logic signed [15:0] S_duv,
  input  logic signed [15:0] S_ref,
  input  logic              END_MULT
);

  numeros_rcsg gen;

  // Cola para guardar los valores del modelo de referencia
  logic signed [15:0] ref_queue[$];

  int total_tests = 0;
  int pass_tests  = 0;
  int fail_tests  = 0;

  // Covergroup: cobertura funcional por paridad
  covergroup cg_valores @(posedge END_MULT);
    cpA : coverpoint A[0] { bins par = {1'b0}; bins imp = {1'b1}; }
    cpB : coverpoint B[0] { bins par = {1'b0}; bins imp = {1'b1}; }
    cp_cross : cross cpA, cpB; // PP, PI, IP, II
  endgroup

  cg_valores cv;

  //--------------------------------------------------------
  // Task principal: aplica estímulos y compara resultados
  //--------------------------------------------------------
  task automatic apply_and_check(
    input logic signed [7:0] a_i,
    input logic signed [7:0] b_i,
    input string             tag
  );
    logic signed [15:0] exp_s;
    begin
      @(negedge clk);
      A     = a_i;
      B     = b_i;
      start = 1'b1;
      @(negedge clk);
      start = 1'b0;

      // Guardamos el valor ideal en la cola
      #1 ref_queue.push_back(S_ref);

      // Esperamos a que termine el DUV
      @(posedge END_MULT);
      exp_s = ref_queue.pop_front();
      total_tests++;

      // Aserción de verificación estructurada
      assert (S_duv === exp_s)
        else begin
          fail_tests++;
          $error("[%0t] %s FAIL A=%0d B=%0d -> DUV=%0d REF=%0d",
                 $time, tag, a_i, b_i, S_duv, exp_s);
        end

      if (S_duv === exp_s) begin
        pass_tests++;
        $display("[%0t] %s OK   A=%0d B=%0d -> %0d",
                 $time, tag, a_i, b_i, S_duv);
      end

      // Muestreamos cobertura
      cv.sample();
      @(negedge clk);
    end
  endtask


  //--------------------------------------------------------
  // Bloque principal
  //--------------------------------------------------------
  initial begin
    gen = new();
    cv  = new();

    reset = 1'b0;
    start = 1'b0;
    A     = '0;
    B     = '0;
    repeat (5) @(negedge clk);
    reset = 1'b1;
    @(negedge clk);

    // Desactivar constraints
    gen.c_PP.constraint_mode(0);
    gen.c_PI.constraint_mode(0);
    gen.c_IP.constraint_mode(0);
    gen.c_II.constraint_mode(0);

    // === FASES DE VERIFICACIÓN ===
    $display("\n[FASE 1] PARES x PARES");
    gen.c_PP.constraint_mode(1);
    while (cv.cp_cross.get_coverage() < 25.0) begin
      assert(gen.randomize());
      apply_and_check(gen.A, gen.B, "PP");
    end
    gen.c_PP.constraint_mode(0);

    $display("\n[FASE 2] PARES x IMPARES");
    gen.c_PI.constraint_mode(1);
    while (cv.cp_cross.get_coverage() < 50.0) begin
      assert(gen.randomize());
      apply_and_check(gen.A, gen.B, "PI");
    end
    gen.c_PI.constraint_mode(0);

    $display("\n[FASE 3] IMPARES x PARES");
    gen.c_IP.constraint_mode(1);
    while (cv.cp_cross.get_coverage() < 75.0) begin
      assert(gen.randomize());
      apply_and_check(gen.A, gen.B, "IP");
    end
    gen.c_IP.constraint_mode(0);

    $display("\n[FASE 4] IMPARES x IMPARES");
    gen.c_II.constraint_mode(1);
    while (cv.cp_cross.get_coverage() < 100.0) begin
      assert(gen.randomize());
      apply_and_check(gen.A, gen.B, "II");
    end
    gen.c_II.constraint_mode(0);

    // -------- RESUMEN --------
    $display("\n======================================");
    $display("  RESUMEN VERIFICACIÓN AVANZADA (único fichero)");
    $display("  Total tests : %0d", total_tests);
    $display("  Passed      : %0d", pass_tests);
    $display("  Failed      : %0d", fail_tests);
    $display("  Cobertura cross paridad: %0.2f %%",
             cv.cp_cross.get_coverage());
    $display("======================================");

    if (fail_tests == 0 && cv.cp_cross.get_coverage() == 100.0)
      $display("STATUS: OK ✅ (DUV == Modelo ideal en 100%%)");
    else
      $display("STATUS: ERROR ❌");

    $finish;
  end

endprogram


//----------------------------------------------------------
// Módulo TB: instancia del DUV, modelo ideal y program
//----------------------------------------------------------
module tb_multipli_top;

  logic clk;
  logic reset;
  logic start;
  logic signed [7:0]  A, B;
  logic signed [15:0] S_duv, S_ref;
  logic               END_MULT;

  // DUV: multiplicador secuencial Booth con signo
  multipli #(.tamano(8)) duv (
    .CLOCK    (clk),
    .RESET    (reset),
    .START    (start),
    .A        (A),
    .B        (B),
    .S        (S_duv),
    .END_MULT (END_MULT)
  );

  // Modelo de referencia
  multipli_parallel ref_model (
    .A (A),
    .B (B),
    .S (S_ref)
  );

  // Program de verificación
  tb_multipli_prog tb_env (
    .clk      (clk),
    .reset    (reset),
    .start    (start),
    .A        (A),
    .B        (B),
    .S_duv    (S_duv),
    .S_ref    (S_ref),
    .END_MULT (END_MULT)
  );

  // Reloj
  always #5 clk = ~clk;

  initial clk = 0;

endmodule